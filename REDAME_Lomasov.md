Выполнил аспирант филиала МГУ в г. Саров, Ломасов Д.В.
# Задание 01: “Цыпа, декодируй это!”
Требуется написать две функции на языке Julia, каждая их которых
выполняет декодирование двоичного линейного кода.

##  2.1. Функция decodeISD.

Функция должна реализовывать алгоритм декодирования с использованием информационных множеств. При этом количество прогонов (попыток)
алгоритма должно быть ограничено величиной niter. Если значение niter
отрицательное, то количество прогонов не ограничивается и алгоритм работает до перебора всех информационных множеств, либо до поиска решения.


---

## Теоретические основы метода

Пусть дано линейное $(n, k)$-кодирование с генераторной матрицей
$G \in \mathbb{F}_2^{k \times n}$.

Кодовое слово определяется как
$$ c = m G, \quad m \in \mathbb{F}_2^k $$

$$ y = c + e, \quad e \in \mathbb{F}_2^n $$


Задача декодирования — найти сообщение $m$ и вектор ошибок $e$ по известным $G$ и $y$.


## Описание алгоритма

Алгоритм повторяет случайный выбор информационного множества до нахождения корректного решения или достижения лимита итераций.

**Пошагово:**

1. Случайно выбрать множество индексов $I$ длиной $k$;
2. Проверить, что подматрица $G_I$ обратима над $\mathbb{F}_2$;
3. Найти $m = G_I^{-1} y_I$;
4. Построить $\hat{y} = mG$ и посчитать ошибки $e = y + \hat{y}$;
5. Если $w(e) = t$, завершить алгоритм;
6. Иначе — повторять.

---


### Основные функции:

* `mul_mod2(A, B)` — умножение матриц и векторов по модулю 2;
* `inv_mod2(A)` — обращение матрицы над $\mathbb{F}_2$ методом Гаусса;
* `decodeISD(G, y, t)` — основной цикл алгоритма.

---

### Основной код:

```julia
function decodeISD(G, y, t; niter = -1)
    k, n = size(G)
    iter = 0

    while niter < 0 || iter < niter
        iter += 1

        I = sort(rand(1:n, k))

        GI = G[:, I]
        GI_inv, ok = inv_mod2(GI)
        if !ok
            continue
        end

        m_candidate = mul_mod2(transpose(GI_inv), y[I])
        y_hat = mul_mod2(m_candidate, G)

        e = [(y[i] + y_hat[i]) % 2 for i in 1:n]

        if sum(e) == t
            println("решение найдено,на итерации $iter")
            return m_candidate, e
        end
    end

    println("решение не найдено, $iter итераций")
    return nothing
end
```

---

##  Тест

### Входные данные:

```julia
G = [
    1 0 0 1 1 0;
    0 1 0 0 1 1;
    0 0 1 1 0 1
]

y = [1, 1, 1, 0, 1, 0]

t = 2
```

### Результаты выполнения:


| № запуска | Итерация, на которой найдено решение | Вектор `m` |   Вектор `e`  |
| :-------: | :----------------------------------: | :---------------------: | :------------------: |
|     1     |                  20                  |       `[1, 0, 1]`       | `[0, 1, 0, 0, 0, 1]` |
|     2     |                   2                  |       `[0, 1, 1]`       | `[1, 0, 0, 1, 0, 0]` |
|     3     |                  14                  |       `[1, 0, 1]`       | `[0, 1, 0, 0, 0, 1]` |
|     4     |                   6                  |       `[1, 0, 1]`       | `[0, 1, 0, 0, 0, 1]` |
|     5     |                  12                  |       `[0, 1, 1]`       | `[1, 0, 0, 1, 0, 0]` |
|     6     |                   5                  |       `[0, 1, 1]`       | `[1, 0, 0, 1, 0, 0]` |







```python

```

## 2.2. Функция `decodeSTERN`

Функция `decodeSTERN` реализует **алгоритм Штерна** — улучшенный вариант метода декодирования с использованием информационных множеств (ISD), в котором используется поиск коллизий для ускорения вычислений.

---

## Теоретические основы метода

Пусть дана проверочная матрица линейного $(n, k)$-кода:
$$
H \in \mathbb{F}_2^{r \times n}, \quad r = n - k
$$

Для принятого вектора $y$ вычисляется синдром:
$$
s^T = H \cdot e^T
$$

где $e \in \mathbb{F}_2^n$ — вектор ошибок, а $wt(e) = t$ — его вес (число единиц).

Задача декодирования: найти $e$ по известным $H$ и $s$.

---

## Основная идея алгоритма Штерна

Метод Штерна улучшает классический ISD за счёт:

* разбиения позиций на две группы;
* генерации частичных комбинаций одинакового веса $p$;
* поиска совпадающих «префиксов» синдромов (коллизий);
* слияния найденных комбинаций в полный вектор ошибок.

Таким образом, вычислительная сложность снижается примерно в $\sqrt{2}$ раза по сравнению с базовым ISD.

---

## Пошаговое описание алгоритма

1. **Случайная перестановка столбцов матрицы $H$.**
   Это позволяет равномерно исследовать множество информационных подмножеств.

2. **Приведение $H$ к систематическому виду $[I_r | P]$** с помощью элементарных преобразований строк (метод Гаусса над $\mathbb{F}_2$).

3. **Разбиение матрицы $P$ на две половины:**
   $P = [P_1 ;|; P_2]$, где каждая часть имеет $k_1$ и $k_2$ столбцов соответственно.

4. **Генерация всех векторов длины $k_1$ и веса $p$** (функция `get_combos`)
   и вычисление частичных синдромов $v_1 = P_1 e_1^T$.
   Результаты сохраняются в словаре по первым $\ell$ битам.

5. **Аналогично генерируются векторы для $P_2$**, и для каждого вычисленного $v_2$ выполняется поиск совпадений с ранее сохранёнными $v_1$.

6. **Если найдено совпадение (коллизия),** то строится полный вектор ошибок $e$ и проверяется, что $wt(e) = t$.
   Если условие выполняется — найдено решение.

7. **Если решение не найдено,** процесс повторяется с новой перестановкой столбцов до достижения лимита итераций или успеха.

---

## Основные функции

* `get_combos(n, p)` — рекурсивная генерация всех векторов длины `n` и веса `p`;
* `decode_stern(H, t, p, l)` — основной алгоритм Штерна (перестановка, приведение, поиск коллизий).

---

### Основной код:

```julia
function decode_stern(H_in, t_target, p_param, l_param, niter=-1)
    r, n = size(H_in)
    k = n - r
    k1 = k ÷ 2
    k2 = k - k1
    iter_count = 0

    while niter < 0 || iter_count < niter
        iter_count += 1
        perm = randperm(n)
        
        M = zeros(Int, r, n)
        for i in 1:r
            for j in 1:n
                M[i, j] = H_in[i, perm[j]]
            end
        end

        pivot_cols = Int[]
        row = 1
        for j in 1:n
            row > r && break
            sel = -1
            for i in row:r
                if M[i, j] == 1
                    sel = i
                    break
                end
            end
            if sel != -1
                M[row, :], M[sel, :] = M[sel, :], M[row, :]
                for i in 1:r
                    if i != row && M[i, j] == 1
                        for col in 1:n
                            M[i, col] = M[i, col] != M[row, col] ? 1 : 0
                        end
                    end
                end
                push!(pivot_cols, j)
                row += 1
            end
        end

        length(pivot_cols) < r && continue

        other_cols = Int[]
        for j in 1:n
            if !(j in pivot_cols) push!(other_cols, j) end
        end

        P = zeros(Int, r, k)
        for i in 1:r
            for j in 1:k
                P[i, j] = M[i, other_cols[j]]
            end
        end

        table = Dict{Vector{Int}, Vector{Vector{Int}}}()
        for e1 in get_combos(k1, p_param)
            val = zeros(Int, r)
            for j in 1:k1
                if e1[j] == 1
                    for i in 1:r
                        val[i] = val[i] != P[i, j] ? 1 : 0
                    end
                end
            end
            key = val[1:l_param]
            if !haskey(table, key) table[key] = [] end
            push!(table[key], e1)
        end

        for e2 in get_combos(k2, p_param)
            val = zeros(Int, r)
            for j in 1:k2
                if e2[j] == 1
                    for i in 1:r
                        val[i] = val[i] != P[i, k1+j] ? 1 : 0
                    end
                end
            end
            
            key = val[1:l_param]
            if haskey(table, key)
                for e1 in table[key]
                    e_syst = zeros(Int, r)
                    for i in 1:r
                        v1_i = 0
                        for j in 1:k1
                            if e1[j] == 1 v1_i = v1_i != P[i, j] ? 1 : 0 end
                        end
                        e_syst[i] = v1_i != val[i] ? 1 : 0
                    end

                    if sum(e_syst) + sum(e1) + sum(e2) == t_target
                        res_perm = vcat(e_syst, e1, e2)
                        e_final = zeros(Int, n)
                        final_order = vcat(pivot_cols, other_cols)
                        for i in 1:n
                            e_final[perm[final_order[i]]] = res_perm[i]
                        end
                        return e_final, iter_count
                    end
                end
            end
        end
    end
    return nothing, iter_count
end

```

---

## Тест
Рассматривается задача из 6й лекции
### Входные данные:

```julia
H = [
    1 1 1 1 1 1 1 1;
    0 0 0 0 1 1 1 1;
    0 0 1 1 0 0 1 1;
    0 1 0 1 0 1 0 1
]

t = 4
p = 1
l = 2
niter = 500
```

---

## Результаты выполнения:
Результаты запуска, только уникальные ответы
| № запуска | Итерация, на которой найдено решение | Вектор  $e$ |
| :-: | :-------------: | :------------------------- |
|  1  |        1        | `[1, 0, 0, 1, 1, 0, 0, 1]` |
|  2  |        1        | `[0, 0, 1, 1, 0, 0, 1, 1]` |
|  3  |        4        | `[0, 0, 0, 0, 1, 1, 1, 1]` |
|  4  |        1        | `[0, 1, 1, 0, 0, 1, 1, 0]` |
|  5  |        1        | `[1, 1, 0, 0, 1, 1, 0, 0]` |
|  6  |        1        | `[0, 1, 0, 1, 1, 0, 1, 0]` |
|  7  |        2        | `[0, 1, 1, 0, 1, 0, 0, 1]` |
|  8  |        1        | `[0, 1, 0, 1, 0, 1, 0, 1]` |
|  9  |        1        | `[1, 0, 1, 0, 1, 0, 1, 0]` |
|  10 |        1        | `[1, 1, 1, 1, 0, 0, 0, 0]` |
|  11 |        1        | `[1, 0, 1, 0, 0, 1, 0, 1]` |
|  12 |        1        | `[1, 0, 0, 1, 0, 1, 1, 0]` |

## Изучение поведение алгоритма Штерна для различных значений его параметров
1)При 
```julia
t=1,2,3
```
 за 500 итераций вектор найти не удалось.

2)При
```julia
p=2,3
```
за 500 итераций вектор найти не удалось.

3)При 
```julia
l=1
```
| № запуска | Итерация, на которой найдено решение | Вектор  $e$ |
| :-: | :-------------: | :------------------------- |
|  1  |        1        | `[1, 1, 0, 0, 0, 0, 1, 1]` |
|  2  |        1        | `[0, 1, 1, 0, 1, 0, 0, 1]` |
|  3  |        1        | `[1, 1, 0, 0, 1, 1, 0, 0]` |
|  4  |        1        | `[0, 1, 1, 0, 0, 1, 1, 0]` |
|  5  |        1        | `[0, 0, 1, 1, 0, 0, 1, 1]` |
|  6  |        1        | `[1, 0, 1, 0, 1, 0, 1, 0]` |
|  7  |        1        | `[0, 0, 0, 0, 1, 1, 1, 1]` |
|  8  |        1        | `[0, 1, 0, 1, 0, 1, 0, 1]` |



```python

```
